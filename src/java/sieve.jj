/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. sieve.jj */
/*@egen*/options {                                                                                                                    
  STATIC = false;
  JAVA_UNICODE_ESCAPE = true;  
  DEBUG_PARSER = false;                                                   
}

PARSER_BEGIN(SieveParser)

package com.synsys.sieve.parser;

import com.synsys.sieve.*;

public class SieveParser/*@bgen(jjtree)*/implements SieveParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSieveParserState jjtree = new JJTSieveParserState();

/*@egen*/ }

PARSER_END(SieveParser)

/*****************************************
 * THE SIEVE LANGUAGE TOKENS STARTS HERE *
 *****************************************/

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <HASH_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| 
  <BRACKET_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* Can't make this one special */
{
  <EOF_HASH_COMMENT: "#" (~["\n","\r"])*>
}              


// identifier = (ALPHA / "_") *(ALPHA DIGIT "_")
TOKEN : /* IDENTIFIER */
{
   <IDENTIFIER: (<ALPHA>|"_") (<ALPHA>|<DIGIT>|"_")*>
|
  < #ALPHA:
      [
       "A"-"Z",
       "a"-"z"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9"
      ]
  >  
}

// tag = ":" identifier
TOKEN : /* TAG */
{
   <TAG: ":" <IDENTIFIER> >
}

TOKEN : /* LITERALS */
{
// number = 1*DIGIT [QUANTIFIER]
// QUANTIFIER = "K" / "M" / "G"
   < NUMBER: 
       <DECIMAL_LITERAL> (<QUANTIFIER>)?
   >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #QUANTIFIER: ["K","M","G"] >    
|
// quoted-string = DQUOTE *CHAR DQUOTE
// in general, \ CHAR inside a string maps to CHAR
// so \" maps to " and \\ maps to \
// note that newlines and other characters are all allowed strings
  < QUOTED_STRING:
      "\""
      (~["\""])*
      "\""
  >
|
// multi-line = "text:" *(SP / HTAB) (hash-comment / CRLF)
//               *(multi-line-literal / multi-line-dotstuff)
//               "." CRLF
// Hmm. What we need to do is treat (CRLF / LF / CR) as <NEWLINE> throughout
  < MULTI_LINE:
      <MULTI_LINE_START>
      (<MULTI_LINE_LITERAL> |<MULTI_LINE_DOTSTUFF>)*
      <MULTI_LINE_END>
  >
|
  <#MULTI_LINE_START: 
      ("text:")
      ([" ", "\t"])*
      (<HASH_COMMENT>|<NEWLINE>)
  >
|
  <#MULTI_LINE_END:
      ("." <NEWLINE>)
  >              
|
  <#NEWLINE:
      ("\n"|"\r"|"\r\n")
  >
|                           
// multi-line-literal  = [CHAR-NOT-DOT *CHAR_NOT_NEWLINE] NEWLINE 
  < #MULTI_LINE_LITERAL:
      (<CHAR_NOT_DOT> (<CHAR_NOT_NEWLINE>)*)?
      <NEWLINE>
  >  
|
  < #CHAR_NOT_DOT: 
      (~["."])
  >
|
  < #CHAR_NOT_NEWLINE: 
      (~["\n"] | ("\r" ~["\n"]))
  >   
|
// multi-line-dotstuff = "." 1*CHAR-NOT-CRLF CRLF
// A line containing only "." ends the multi-line.
// Remove a leading '.' if followed by another '.'.
  < #MULTI_LINE_DOTSTUFF:
    "."
    (<CHAR_NOT_NEWLINE>)+
    <NEWLINE>
  >  
}

/******************************************
 * THE SIEVE LANGUAGE GRAMMAR STARTS HERE *
 ******************************************/

// start = commands   
SimpleNode start() :
{/*@bgen(jjtree) start */
  ASTstart jjtn000 = new ASTstart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  }
{/*@bgen(jjtree) start */
  try {
/*@egen*/
  commands()
  (<EOF_HASH_COMMENT>)? // Allow a Hash comment immediately prior to EOF
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/  
}

//   commands = *command
void commands() :
{/*@bgen(jjtree) commands */
  ASTcommands jjtn000 = new ASTcommands(JJTCOMMANDS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) commands */
  try {
/*@egen*/
  (command())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//   command = identifier arguments ( ";" / block )
void command() :
{/*@bgen(jjtree) command */
  ASTcommand jjtn000 = new ASTcommand(JJTCOMMAND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token identifier = null; }
{/*@bgen(jjtree) command */
  try {
/*@egen*/
  (identifier = <IDENTIFIER>) arguments() (";" | block())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setName(identifier.image);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/  
}

//   block = "{" commands "}"
void block() :
{/*@bgen(jjtree) block */
  ASTblock jjtn000 = new ASTblock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) block */
   try {
/*@egen*/
   "{" commands() "}"/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

//   arguments = *argument [test / test-list]
void arguments() :
{/*@bgen(jjtree) arguments */
  ASTarguments jjtn000 = new ASTarguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) arguments */
  try {
/*@egen*/
  (argument())* (test() | test_list())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//    argument = string-list / number / tag
void argument() :
{/*@bgen(jjtree) argument */
  ASTargument jjtn000 = new ASTargument(JJTARGUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token string_list = null, number = null, tag = null; }
{/*@bgen(jjtree) argument */
  try {
/*@egen*/
  (string_list() | number = <NUMBER> | tag = <TAG>)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    Argument value = null; 
    if (null != number)
       value = new NumberArgument(number);
    else if (null != tag)
       value = new TagArgument(tag);
    jjtn000.setValue(value);       
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//   test = identifier arguments
void test() :
{/*@bgen(jjtree) test */
  ASTtest jjtn000 = new ASTtest(JJTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token identifier = null; }
{/*@bgen(jjtree) test */
  try {
/*@egen*/
  (identifier = <IDENTIFIER> arguments())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setName(identifier.image);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/   
}

//   test-list = "(" test *("," test) ")"
void test_list() :
{/*@bgen(jjtree) test_list */
  ASTtest_list jjtn000 = new ASTtest_list(JJTTEST_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) test_list */
  try {
/*@egen*/
  "(" test() ("," test())* ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//   string = quoted-string / multi-line
void string() :
{/*@bgen(jjtree) string */
  ASTstring jjtn000 = new ASTstring(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token quoted_string = null, multi_line = null;}
{/*@bgen(jjtree) string */
  try {
/*@egen*/
  (quoted_string = <QUOTED_STRING> | multi_line = <MULTI_LINE>)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (null != quoted_string)
      jjtn000.setValue(quoted_string.image);
    else if (null != multi_line)
      jjtn000.setValue(multi_line.image);  
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//   string-list = "[" string *("," string) "]" / string         ;; if
//   there is only a single string, the brackets are optional
void string_list() :
{/*@bgen(jjtree) string_list */
  ASTstring_list jjtn000 = new ASTstring_list(JJTSTRING_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) string_list */
  try {
/*@egen*/
  ("[" string() ("," string())* "]") | string()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


   
 