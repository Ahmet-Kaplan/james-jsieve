options {
  JAVA_UNICODE_ESCAPE = true; // Allows unicode for CR and LF
  DEBUG_PARSER = true;
}

PARSER_BEGIN(SieveParser)

public class SieveParser {

  public static void main(String args[]) {
    SieveParser parser;
    if (args.length == 0) {
      System.out.println("Sieve Parser Version 0.0.1:  Reading from standard input . . .");
      parser = new SieveParser(System.in);
    } else if (args.length == 1) {
      System.out.println("Sieve Parser Version 0.0.1:  Reading from file " + args[0] + " . . .");
      try {
        parser = new SieveParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Sieve Parser Version 0.0.1:  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Sieve Parser Version 0.0.1:  Usage is one of:");
      System.out.println("         java SieveParser < inputfile");
      System.out.println("OR");
      System.out.println("         java SieveParser inputfile");
      return;
    }
    try {
      parser.start();
      System.out.println("Sieve Parser Version 0.0.1:  Sieve program parsed successfully.");
    } catch (ParseException e) {
      System.out.println("Sieve Parser Version 0.0.1:  Encountered errors during parse.");
      System.out.println("                             Parse Exception: " + e.getMessage());     
    }
  }

}

PARSER_END(SieveParser)

/*****************************************
 * THE SIEVE LANGUAGE TOKENS STARTS HERE *
 *****************************************/

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <HASH_COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| 
  <BRACKET_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}              


// identifier = (ALPHA / "_") *(ALPHA DIGIT "_")
TOKEN : /* IDENTIFIER */
{
   <IDENTIFIER: (<ALPHA>|"_") (<ALPHA>|<DIGIT>|"_")*>
|
  < #ALPHA:
      [
       "\u0041"-"\u005a",
       "\u0061"-"\u007a"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039"
      ]
  >  
}

// tag = ":" identifier
TOKEN : /* TAG */
{
   <TAG: ":" <IDENTIFIER> >
}

TOKEN : /* LITERALS */
{
// number = 1*DIGIT [QUANTIFIER]
// QUANTIFIER = "K" / "M" / "G"
   < NUMBER: 
       <DECIMAL_LITERAL> (<QUANTIFIER>)?
   >
|
  < #DECIMAL_LITERAL: (["0"-"9"])+ >
|
  < #QUANTIFIER: ["K","M","G"] >    
|
// quoted-string = DQUOTE *CHAR DQUOTE
// in general, \ CHAR inside a string maps to CHAR
// so \" maps to " and \\ maps to \
// note that newlines and other characters are all allowed strings
  < QUOTED_STRING:
      "\""
      (["\u0001"-"\u007f" ])*
      "\""
  >
|
// multi-line = "text:" *(SP / HTAB) (hash-comment / CRLF)
//               *(multi-line-literal / multi-line-dotstuff)
//               "." CRLF
// Switch approach
  <MULTI_LINE: <MULTI_LINE_NEW>>
  |
  < #MULTI_LINE_OLD:
      "text:"
      ([" ", "\t"])*
      <HASH_COMMENT>|"\r\n"
      (<MULTI_LINE_LITERAL>|<MULTI_LINE_DOTSTUFF>)*
      "." "\r\n"
  >

// Hmm. What we need to do is treat (CRLF / LF / CR) as <NEWLINE> throughout
|
  < #MULTI_LINE_NEW:
      ("text:")
      ([" ", "\t"])*
      <HASH_COMMENT>|<NEWLINE>
      (<MULTI_LINE_LITERAL_NEW>|<MULTI_LINE_DOTSTUFF_NEW>)*
      "." <NEWLINE>
  > 
|
  <#NEWLINE:
      ("\n"|"\r"|"\r\n")
  >
|                           
// multi-line-literal  = [CHAR-NOT-DOT *CHAR-NOT-CRLF] CRLF 
  < #MULTI_LINE_LITERAL:
      <CHAR_NOT_DOT>
      (<CHAR_NOT_CRLF>)*
      "\r\n"
  >
|                           
// multi-line-literal  = [CHAR-NOT-DOT *CHAR_NOT_NEWLINE] NEWLINE 
  < #MULTI_LINE_LITERAL_NEW:
      (<CHAR_NOT_DOT> (<CHAR_NOT_NEWLINE>)*)?
      <NEWLINE>
  >  
|
  < #CHAR_NOT_DOT: 
      [
        "\u0001"-"\u002d",
        "\u002f"-"\u007f"
      ]
  >
|
  < #CHAR_NOT_CR: 
      [
        "\u0001"-"\u000c",
        "\u000e"-"\u007f"
      ]
  > 
|
// Technically incorrect! Need to use inclusive renges so gt: 7F is excluded
  < #CHAR_NOT_NEWLINE: 
      (~["\n"] | ("\r" ~["\n"]))
  >   
|   
  < #CHAR_NOT_CRLF: 
        ("\r" ~["\n"]) | <CHAR_NOT_CR>
  >
|
// multi-line-dotstuff = "." 1*CHAR-NOT-CRLF CRLF
// A line containing only "." ends the multi-line.
// Remove a leading '.' if followed by another '.'.
  <#MULTI_LINE_DOTSTUFF:
    "."
    <CHAR_NOT_CRLF>
    "\r\n"
  >
|
// multi-line-dotstuff = "." 1*CHAR-NOT-CRLF CRLF
// A line containing only "." ends the multi-line.
// Remove a leading '.' if followed by another '.'.
  <#MULTI_LINE_DOTSTUFF_NEW:
    "."
    <CHAR_NOT_NEWLINE>
    <NEWLINE>
  >  
}

/******************************************
 * THE SIEVE LANGUAGE GRAMMAR STARTS HERE *
 ******************************************/

// start = commands   
void start() :
{  }
{
  commands() <EOF>
}

//   commands = *command
void commands() :
{ }
{
  command()
}

//   command = identifier arguments ( ";" / block )
void command() :
{ }
{
  <IDENTIFIER> arguments() (";" | block())
}

//   block = "{" commands "}"
void block() :
{ }
{
   "{" commands() "}"
}

//   arguments = *argument [test / test-list]
void arguments() :
{ }
{
  (argument())* // (test() | test_list())?
}

//    argument = string-list / number / tag
void argument() :
{ }
{
  string_list() | <NUMBER> | <TAG>
}

//   test = identifier arguments
void test() :
{ }
{
  <IDENTIFIER> arguments()
}

//   test-list = "(" test *("," test) ")"
void test_list() :
{ }
{
  "(" test() ("," test())* ")"
}

//   string = quoted-string / multi-line
void string() :
{ }
{
  <QUOTED_STRING> | <MULTI_LINE>
}

//   string-list = "[" string *("," string) "]" / string         ;; if
//   there is only a single string, the brackets are optional
void string_list() :
{ }
{
  ("[" string() ("," string())* "]") | string()
}


   
 